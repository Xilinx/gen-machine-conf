#!/usr/bin/env python3

# Copyright (C) 2021-2022, Xilinx, Inc.  All rights reserved.
# Copyright (C) 2022, Advanced Micro Devices, Inc.  All rights reserved.
#
# SPDX-License-Identifier: MIT

import argparse
import logging
from gen_plnx_machine import *


def update_localconf(args, plnx_conf_file, machine_conf_file):
    builddir = ''
    machine_conf_path = os.path.join(args.output, machine_conf_file +
                                     '.conf')
    plnx_conf_path = os.path.join(args.output, plnx_conf_file)

    if 'BUILDDIR' in os.environ.keys():
        builddir = os.environ['BUILDDIR']
    if builddir:
        local_conf = os.path.join(builddir, 'conf/local.conf')
        if not os.path.isfile(local_conf):
            logger.debug('No local.conf file found in %s/conf directory to add .conf'
                         ' file' % builddir)
        else:
            # Check if the build/xsa directory exist or not.
            # Copy XSA from HDF_PATH to ${TOPDIR}/xsa/machine_conf_file
            # directory if not --petalinux
            if not args.petalinux:
                xsapath = os.path.join(builddir, 'xsa', machine_conf_file)
                if not os.path.exists(xsapath):
                    os.makedirs(xsapath)
                shutil.copy2(args.hw_description, xsapath)

            # Copy Yocto machine configuration file to ${TOPDIR}/conf/machine
            # directory.
            # Check if the build/conf/machine directory exist or not.
            machine_dir = os.path.join(builddir, 'conf', 'machine')
            if not os.path.exists(machine_dir):
                os.makedirs(machine_dir)
            shutil.copy2(machine_conf_path, machine_dir)

            if args.petalinux:
                # Copy plnxtool.conf file to ${TOPDIR}/conf directory
                shutil.copy2(plnx_conf_path, builddir + '/conf/')
                file_str = 'include conf/plnxtool.conf'
                with open(local_conf, 'r') as local_conf_f:
                    lines = local_conf_f.readlines()
                local_conf_f.close()
                str_found = ''
                for line in lines:
                    if re.search(file_str, line):
                        str_found = True
                        break
                if not str_found:
                    with open(local_conf, 'a') as local_conf_f:
                        local_conf_f.write(file_str)
                    local_conf_f.close()


def main():
    parser = argparse.ArgumentParser(description='PetaLinux/Yocto xsa to Machine '
                                     'Configuration File '
                                     'generation tool',
                                     formatter_class=argparse.RawTextHelpFormatter,
                                     usage='%(prog)s --soc-family '
                                     '[SOC_FAMILY] [--hw-description'
                                     ' <PATH_TO_XSA>/<xsa_name>.xsa]'
                                     ' [--machine-name] [other options]')
    optional_args = parser._action_groups.pop()

    required_args = parser.add_argument_group('required arguments')
    required_args.add_argument('--soc-family', metavar='', required=True,
                               choices=['microblaze', 'zynq',
                                        'zynqmp', 'versal'],
                               help='Specify SOC family type from choice list.')
    required_args.add_argument('--hw-description',
                               metavar='\t<PATH_TO_XSA>/<xsa_name>.xsa',
                               required=True, help='Specify Hardware(xsa) file')
    optional_args.add_argument('--machine-name', metavar='', help='Provide a '
                               'name to generate machine configuration',
                               dest='machine', type=str)
    optional_args.add_argument('--output',
                               metavar='', help='Output directory name',
                               default='')
    optional_args.add_argument('--xsct-tool', metavar='',
                               help='Vivado or Vitis XSCT path to use xsct '
                                    'commands')
    optional_args.add_argument('--native-sysroot', metavar='', help='Native '
                               'sysroot path to use the mconf/conf commands.')
    optional_args.add_argument('--menuconfig', help='UI menuconfig option '
                               'to update configuration.'
                               '\nproject - To update System Level configurations '
                               '\nrootfs  - To update Rootfs configurations',
                               choices=['project', 'rootfs'])
    optional_args.add_argument('--petalinux', help='Update the build/local.conf file '
                               'with generated .conf files.', action='store_true')
    optional_args.add_argument('--debug', help='Output debug information on console',
                               default=False, action='store_true')
    parser._action_groups.append(optional_args)
    args = parser.parse_args()

    # If user specified output directory dont add soc_family
    if not args.output:
        args.output = os.path.join(os.getcwd(), 'output', args.soc_family)
    else:
        args.output = os.path.realpath(args.output)
    if not os.path.exists(args.output):
        os.makedirs(args.output)

    args.logfile = os.path.join(args.output, 'gen-machineconf.log')
    if os.path.exists(args.logfile):
        shutil.move(args.logfile,
                    os.path.join(args.output, 'gen-machineconf.log.old'))

    # Setup logger to file
    logger_setup.setup_logger_file(args.logfile)
    if args.debug:
        console_h.setLevel(logging.DEBUG)

    # Check SDK toolchain path
    if args.xsct_tool:
        if not os.path.isdir(args.xsct_tool):
            logger.error('XSCT_TOOL path not found: %s' % args.xsct_tool)
            sys.exit(255)
        else:
            os.environ["PATH"] += os.pathsep + args.xsct_tool + '/bin'
    else:
        command = "bitbake -e"
        logger.info('Getting XILINX_SDK_TOOLCHAIN path...')
        stdout, stderr = run_cmd(command, os.getcwd(), args.logfile)
        sdk_xsct = ''
        for line in stdout.splitlines():
            if line.decode('utf-8').startswith('XILINX_SDK_TOOLCHAIN'):
                xilinx_xsct_tool = line.decode(
                    'utf-8').split('=')[1].replace('"', '')
        if xilinx_xsct_tool and not os.path.isdir(xilinx_xsct_tool):
            logger.error('XILINX_SDK_TOOLCHAIN set to "%s" is doesn\'t exists'
                         ' please set a valid one, or' % xilinx_xsct_tool)
            logger.error(
                'Use --sdk-toolchain option to specify the SDK_XSCT path')
            sys.exit(255)
        elif xilinx_xsct_tool:
            os.environ["PATH"] += os.pathsep + xilinx_xsct_tool + '/bin'

    xsct_exe = shutil.which('xsct')
    if not xsct_exe:
        logger.error('xsct command not found')
        sys.exit(255)
    else:
        logger.debug('Using xsct from : %s' % xsct_exe)

    # Check mconf utilities
    if args.native_sysroot:
        if not os.path.isdir(args.native_sysroot):
            logger.error('Native sysroot path doesnot exists: %s'
                         % args.native_sysroot)
            sys.exit(255)
        else:
            os.environ["PATH"] += os.pathsep + args.native_sysroot + '/usr/bin'
    else:
        mconf_provides = "kconfig-frontends-native"
        command = "bitbake -e %s" % (mconf_provides)
        logger.info('Getting kconfig-frontends sysroot path...')
        stdout, stderr = run_cmd(command, os.getcwd(), args.logfile)
        sysroot_path = ''
        sysroot_destdir = ''
        staging_bindir_native = ''
        native_package_path_suffix = ''
        for line in stdout.splitlines():
            if line.startswith('SYSROOT_DESTDIR'):
                sysroot_destdir = line.split('=')[1].replace('"', '')
            elif line.startswith('STAGING_BINDIR_NATIVE'):
                staging_bindir_native = line.split('=')[1].replace('"', '')
            elif line.startswith('NATIVE_PACKAGE_PATH_SUFFIX'):
                native_package_path_suffix = line.split('=')[1].replace('"', '')
        sysroot_path = '%s%s%s' % (sysroot_destdir, staging_bindir_native,
                                   native_package_path_suffix)
        scripts = ['mconf', 'conf']
        not_found = False
        for script in scripts:
            if not os.path.isfile(os.path.join(sysroot_path, script)):
                not_found = True
            elif os.path.isfile(os.path.join(sysroot_path, script)) and not \
                    os.access(os.path.join(sysroot_path, script), os.X_OK):
                not_found = True
        if not_found:
            logger.debug('INFO: Running CMD: bitbake %s' % mconf_provides)
            subprocess.check_call(["bitbake", mconf_provides])
        os.environ["PATH"] += os.pathsep + sysroot_path

    conf_exe = shutil.which('mconf')
    if not conf_exe:
        logger.error('mconf/conf command not found')
        sys.exit(255)
    else:
        logger.debug('Using conf/mconf from : %s' % conf_exe)

    if args.hw_description:
        get_hw_description(args)

    machine_conf_file = generate_yocto_machine(args)
    plnx_conf_file = generate_plnx_config(args, machine_conf_file)
    update_localconf(args, plnx_conf_file, machine_conf_file)
    if not args.petalinux:
        logger.info('\n \
        ######## Bitbake Build Commands ########\n \
        Run "MACHINE=%s bitbake petalinux-image-minimal"\n\n \
        ######## QEMU boot Commands ########\n \
        Run "MACHINE=%s runqemu slirp nographic"\n'
                    % (machine_conf_file, machine_conf_file))


if __name__ == "__main__":
    try:
        ret = main()
    except Exception:
        ret = 1
        import traceback
        traceback.print_exc()
    sys.exit(ret)
