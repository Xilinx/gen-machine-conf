#!/usr/bin/env python3

# Copyright (C) 2021-2022, Xilinx, Inc.  All rights reserved.
# Copyright (C) 2022-2023, Advanced Micro Devices, Inc.  All rights reserved.
#
# Author:
#       Raju Kumar Pothuraju <rajukumar.pothuraju@amd.com>
#
# SPDX-License-Identifier: MIT


import argparse
import logging
import os
import pathlib
import shutil
import sys

scripts_path = os.path.dirname(os.path.realpath(__file__))
libs_path = scripts_path + '/lib'
sys.path = sys.path + [libs_path]
import logger_setup
import common_utils

logger, console_h = logger_setup.setup_logger('Gen-Machineconf')
plugins = []


# Validate the hw_description given and justify xsct/sdt flow.
def validate_hwfile(hw_description):
    if not os.path.exists(hw_description):
        logger.error('Given path doesnot exists: %s', hw_description)
        sys.exit(255)
    elif os.path.isfile(hw_description):
        hw_ext = pathlib.Path(hw_description).suffix
        if hw_ext != '.xsa':
            logger.error('Only .xsa files are supported given %s' % hw_ext)
            sys.exit(255)
        hw_ext = 'xsct'
    elif os.path.isdir(hw_description):
        sdtfiles = []
        for file in os.listdir(hw_description):
            if file.endswith('.dts'):
                sdtfiles.append(file)
        if not sdtfiles:
            logger.error('No .dts file found in given directory %s' %
                         hw_description)
            sys.exit(255)
        if len(sdtfiles) > 1:
            logger.error(
                'More than one .dts files found in given directory %s' % hw_description)
            sys.exit(255)
        hw_ext = 'sdt'
        hw_description = os.path.join(hw_description, sdtfiles[0])
    else:
        logger.error(
            'Only .xsa file or System Device-tree directory supported.')
        sys.exit(255)
    hw_description = os.path.abspath(hw_description)
    return hw_ext, hw_description


def GetBBPath():
    if shutil.which('bitbake'):
        logger.info('Getting bitbake BBPATH')
        command = 'bitbake -e'
        stdout, stderr = common_utils.RunCmd(command, os.getcwd(), shell=True)
        bbpath = ''
        for line in stdout.splitlines():
            if line.startswith('BBPATH'):
                bbpath = line.split('=')[1].replace('"', '')
        return bbpath
    else:
        logger.debug('No bitbake found skip getting BBPATH')
    return ''


def main():
    parser = argparse.ArgumentParser(
        description='PetaLinux/Yocto Machine Configuration File generation tool',
        formatter_class=argparse.RawTextHelpFormatter, add_help=False,
        epilog='Use %(prog)s <subcommand> --help to get help on a specific command'
    )
    optional_args = parser._action_groups.pop()
    required_args = parser.add_argument_group('required arguments')

    required_args.add_argument('--hw-description', metavar='[<PATH_TO_XSA>/<xsa_name>.xsa]',
                               help='Specify Hardware(xsa) file or System Device-tree Directory',
                               type=os.path.realpath)
    optional_args.add_argument('--soc-family', metavar='',
                               choices=['microblaze', 'zynq',
                                        'zynqmp', 'versal'],
                               help='SOC family type from choice list (usually auto detected).')
    optional_args.add_argument('--soc-variant', metavar='',
                               help='SOC Variant: Ex: cg, dr, eg, ev, ai-prime, premium (usually auto detected).')
    optional_args.add_argument('--machine-name', metavar='', dest='machine', type=str,
                               help='Provide a name to generate machine configuration')
    optional_args.add_argument('-c', '--config-dir', metavar='<config_dir>',
                            help='Location of the build conf directory', type=os.path.realpath,
                            default=os.path.join(os.environ.get('BUILDDIR',''), 'conf'))
    optional_args.add_argument('-r', '--require-machine', metavar='', type=str,
                               help='This machine will be required, instead of the '
                                    'generic machine if defined')
    optional_args.add_argument('-O', '--machine-overrides', metavar='', type=str,
                               help='Provide additional overrides to the generated machine')
    optional_args.add_argument(
        '--output', metavar='', help='Output directory name', default='')
    optional_args.add_argument('--native-sysroot', metavar='',
                               help='Native sysroot path to use the mconf/conf commands.')
    optional_args.add_argument('--menuconfig', help='UI menuconfig option '
                               'to update configuration(default is project).'
                               '\nproject - To update System Level configurations '
                               '\nrootfs  - To update Rootfs configurations',
                               nargs='?', const='project',
                               choices=['project', 'rootfs'])
    optional_args.add_argument('--petalinux', help='Generate Rootfs and PetaLinux Tool conf '
                               'files and update the build/local.conf file '
                               'with generated .conf files.', action='store_true')
    optional_args.add_argument('--add-rootfsconfig', help='Specify a file with list of '
                               'package names to add into rootfs menu entry',
                               metavar='')
    optional_args.add_argument(
        '-D', '--debug', help='Enable debug output', action='store_true')

    parser._action_groups.append(optional_args)
    global_args, unparsed_args = parser.parse_known_args()

    parser.add_argument('-h', '--help', action='help', default=argparse.SUPPRESS,
                        help='show this help message and exit')

    subparsers = parser.add_subparsers(title='subcommands', metavar='<subcommand>',
                                       dest='subcommand')

    # Try to get BBPATH to load modules
    bbpath = GetBBPath()
    # Load the plugins from BBPATH and lib/gen-machineconf directory
    for path in bbpath.split(':') + [scripts_path]:
        pluginpath = os.path.join(path, 'lib', 'gen-machineconf')
        common_utils.load_plugins(plugins, pluginpath)

    # Register commands from plugins
    for plugin in plugins:
        if hasattr(plugin, 'register_commands'):
            plugin.register_commands(subparsers)

    # Check if help selected to skip hw_description check
    parserhelp = False
    if {'-h', '--help'} & set(unparsed_args):
        parserhelp = True
    
    # Check the hw_description description given or not.
    # Adding check here as required=True with add_argument
    # not working with subparsers parse_known_args().
    if not global_args.hw_description and not parserhelp:
        parser.error('The following arguments are required: %s' %
                     '--hw-description')

    if not parserhelp:
        # Validate the given hw_description and get xsct/sdt
        global_args.hw_flow, global_args.hw_file = validate_hwfile(global_args.hw_description)
    
    # Default option for subparsers is not supported yet in python
    # If user not specified any subparser use the default parser based on the hw_description provided.
    # Get the registed parsers list from subparsers and check with the unparsed_args.
    _hassubcommand = False
    for subcmd in subparsers.choices:
        if subcmd in unparsed_args:
            _hassubcommand = True
            break
    if not _hassubcommand and not parserhelp:
        unparsed_args.insert(0, 'parse-xsa' if global_args.hw_flow == 'xsct' else 'parse-sdt')
    
    args = parser.parse_args(unparsed_args, namespace=global_args)

    # If user specified output directory use it if not add basename of hw_file
    if not args.output:
        args.output = os.path.join(os.getcwd(), 'output',
                                   os.path.basename(args.hw_file).split('.')[0])
    else:
        args.output = os.path.realpath(args.output)
    common_utils.CreateDir(args.output)

    # Define log file
    args.logfile = os.path.join(args.output, 'gen-machineconf.log')
    common_utils.RenameFile(args.logfile,
                            os.path.join(args.output, 'gen-machineconf.log.old'))

    # Setup logger to file
    logger_setup.setup_logger_file(args.logfile)
    if args.debug:
        console_h.setLevel(logging.DEBUG)

    # Add nativesysroot path
    common_utils.AddNativeSysrootPath(args.native_sysroot)

    ret = args.func(args)
    return ret


if __name__ == "__main__":
    try:
        ret = main()
    except Exception:
        ret = 1
        import traceback
        traceback.print_exc()
    sys.exit(ret)
