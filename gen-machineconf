#!/usr/bin/env python3

# Copyright (C) 2021-2022, Xilinx, Inc.  All rights reserved.
# Copyright (C) 2022, Advanced Micro Devices, Inc.  All rights reserved.
#
# SPDX-License-Identifier: MIT

import argparse
from gen_plnx_machine import *

def update_localconf(args, plnx_conf_file, gen_machine_file_name):
    builddir = ''
    gen_machine_conf_path = os.path.join(args.output, gen_machine_file_name + \
                            '.conf')
    plnx_conf_path = os.path.join(args.output, plnx_conf_file)

    if 'BUILDDIR' in os.environ.keys():
        builddir = os.environ['BUILDDIR']
    if builddir:
        # Check if the build/conf/machine directory exist or not.
        if not os.path.exists("conf/machine"):
            os.makedirs("conf/machine")

        # Check if the build/xsa directory exist or not.
        xsapath = os.path.join('xsa/', gen_machine_file_name)
        if not os.path.exists(xsapath):
            os.makedirs(xsapath)

        local_conf = os.path.join(builddir, 'conf/local.conf')
        if not os.path.isfile(local_conf):
            print('No local.conf file found in %s/conf directory to add .conf' \
                  ' file' % builddir)
        else:
            # Copy XSA from HDF_PATH to ${TOPDIR}/xsa/gen_machine_file_name
            # directory
            shutil.copy2(args.hw_description, builddir + '/' + xsapath)

            # Copy Yocto machine configuration file to ${TOPDIR}/conf/machine
            # directory.
            shutil.copy2(gen_machine_conf_path, builddir + '/conf/machine')

            if args.petalinux:
                # Copy plnxtool.conf file to ${TOPDIR}/conf directory
                shutil.copy2(plnx_conf_path, builddir + '/conf/')
                file_str = 'include conf/plnxtool.conf'
                with open(local_conf, 'r') as local_conf_f:
                    lines = local_conf_f.readlines()
                local_conf_f.close()
                str_found = ''
                for line in lines:
                    if re.search(file_str, line):
                        str_found = True
                        break
                if not str_found:
                    with open(local_conf, 'a') as local_conf_f:
                        local_conf_f.write(file_str)
                    local_conf_f.close()

def main():
    parser = argparse.ArgumentParser(description = 'Yocto xsa to Machine '\
                                                   'Configuration File ' \
                                                   'generation tool', \
                                        usage = '%(prog)s --soc-family ' \
                                                '[SOC_FAMILY] [--hw-description'\
                                                ' <PATH_TO_XSA>/<xsa_name>.xsa]'\
                                                '[--custom | --bsp zcu102-zynqmp] '\
                                            ' [--machine-name] [other options]')
    optional_args = parser._action_groups.pop()

    required_args = parser.add_argument_group('required arguments')
    proj_args = parser.add_mutually_exclusive_group()
    required_args.add_argument('--soc-family', metavar='', required=True, \
                               choices=['microblaze', 'zynq', 'zynqmp', 'versal'], \
                               help='Specify SOC family type from choice list.')
    proj_args.add_argument('--custom', help='Specify whether BSP is for custom'\
                                            ' board.', action='store_true')
    proj_args.add_argument('--bsp', metavar='zcu102-zynqmp', \
                           choices=['kc705-microblazeel', 'zc702-zynq7',\
                                    'zc706-zynq7', 'zcu102-zynqmp', \
                                    'zcu104-zynqmp', 'zcu106-zynqmp', \
                                    'zcu111-zynqmp', 'zcu1275-zynqmp', \
                                    'zcu1285-zynqmp', 'zcu208-zynqmp', \
                                    'zcu216-zynqmp', 'vck190-versal', \
                                    'vmk180-versal', 'vck5000-versal', \
                                    'vck-sc-zynqmp', \
                                    ],
                           help='Specify BSP name for Xilinx evaluation board,'\
                                ' Use the BSP name from choice list. '\
                                'For example: zcu102-zynqmp or vck190-versal')
    required_args.add_argument('--hw-description', \
                               metavar='\t<PATH_TO_XSA>/<xsa_name>.xsa',\
                               required=True, help='Specify Hardware(xsa) file')
    optional_args.add_argument('--machine-name', metavar='', help='Provide a '\
                                'name for generated machine configuration', \
                               dest='machine', type=str)
    optional_args.add_argument('--output', \
                               metavar='', help='Output directory name', \
                               default=os.path.join(os.getcwd(),'output'))
    optional_args.add_argument('--xsct-tool', metavar='', \
                               help='Vivado or Vitis XSCT path to use xsct ' \
                                    'commands')
    optional_args.add_argument('--native-sysroot', metavar='', help='Native ' \
                                'sysroot path to use the mconf/conf commands.')
    optional_args.add_argument('--menuconfig', help='UI menuconfig option' \
                                'to update configuration.', action='store_true')
    optional_args.add_argument('--petalinux', help='Update the build/local.conf file ' \
                                'with generated .conf files.', action='store_true')
    parser._action_groups.append(proj_args)
    parser._action_groups.append(optional_args)
    args = parser.parse_args()

    args.output = os.path.join(args.output,args.soc_family)
    # Check SDK toolchain path
    if args.xsct_tool:
        if not os.path.isdir(args.xsct_tool):
            print('ERROR: XSCT_TOOL path not found: %s' % args.xsct_tool)
            sys.exit(255)
        else:
            os.environ["PATH"] += os.pathsep + args.xsct_tool + '/bin'
    else:
        print('INFO: Running CMD: bitbake -e')
        process = subprocess.Popen(['bitbake','-e'],
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()
        sdk_xsct = ''
        for line in stdout.splitlines():
            if line.decode('utf-8').startswith('XILINX_SDK_TOOLCHAIN'):
                xilinx_xsct_tool = line.decode('utf-8').split('=')[1].replace('"','')
        if xilinx_xsct_tool and not os.path.isdir(xilinx_xsct_tool):
            print('ERROR: XILINX_SDK_TOOLCHAIN set to "%s" is doesn\'t exists' \
                  ' please set a valid one, or' % xilinx_xsct_tool)
            print('Use --sdk-toolchain option to specify the SDK_XSCT path')
            sys.exit(255)
        elif xilinx_xsct_tool:
            os.environ["PATH"] += os.pathsep + xilinx_xsct_tool + '/bin'

    xsct_exe = shutil.which('xsct')
    if not xsct_exe:
        print('ERROR: xsct command not found')
        sys.exit(255)
    else:
        print('INFO: Using xsct from : %s' % xsct_exe)

    # Check mconf utilities
    if args.native_sysroot:
        if not os.path.isdir(args.native_sysroot):
            print('ERROR: Native sysroot path doesnot exists: %s' \
                  % args.native_sysroot)
            sys.exit(255)
        else:
            os.environ["PATH"] += os.pathsep + args.native_sysroot + '/usr/bin'
    else:
        mconf_provides = "kconfig-frontends-native"
        print('INFO: Getting kconfig-frontends sysroot path')
        process = subprocess.Popen(['bitbake','-e',mconf_provides],
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
        stdout, stderr = process.communicate()
        sysroot_path = ''
        sysroot_destdir = ''
        staging_bindir_native = ''
        native_package_path_suffix = ''
        for line in stdout.splitlines():
            if line.decode('utf-8').startswith('SYSROOT_DESTDIR'):
                sysroot_destdir = line.decode('utf-8').split('=')[1].replace('"','')
            elif line.decode('utf-8').startswith('STAGING_BINDIR_NATIVE'):
                staging_bindir_native = line.decode('utf-8').split('=')[1].replace('"','')
            elif line.decode('utf-8').startswith('NATIVE_PACKAGE_PATH_SUFFIX'):
                native_package_path_suffix = line.decode('utf-8').split('=')[1].replace('"','')
        sysroot_path = '%s%s%s' % (sysroot_destdir,staging_bindir_native, \
                                   native_package_path_suffix)
        scripts = ['mconf', 'conf']
        not_found = False
        for script in scripts:
            if not os.path.isfile(os.path.join(sysroot_path,script)):
                not_found = True
            elif os.path.isfile(os.path.join(sysroot_path,script)) and not \
                    os.access(os.path.join(sysroot_path,script), os.X_OK):
                not_found = True
        if not_found:
            print('INFO: Running CMD: bitbake %s' % mconf_provides)
            subprocess.check_call(["bitbake", mconf_provides])
        os.environ["PATH"] += os.pathsep + sysroot_path

    conf_exe = shutil.which('mconf')
    if not conf_exe:
        print('ERROR: mconf/conf command not found')
        sys.exit(255)
    else:
        print('INFO: Using conf/mconf from : %s' % conf_exe)

    if args.hw_description:
        get_hw_description(args)

    gen_machine_file_name = generate_yocto_machine(args)
    plnx_conf_file = generate_plnx_config(args, gen_machine_file_name)
    update_localconf(args, plnx_conf_file, gen_machine_file_name)
    print('\n######## Bitbake Build Commands ########\n')
    print('Run "MACHINE=%s bitbake petalinux-image-minimal"\n'\
          % gen_machine_file_name)
    print('\n######## QEMU boot Commands ########\n')
    print('Run "MACHINE=%s runqemu slirp nographic"\n'\
          % gen_machine_file_name)

if __name__ == "__main__":
    try:
        ret = main()
    except Exception:
        ret = 1
        import traceback
        traceback.print_exc()
    sys.exit(ret)
